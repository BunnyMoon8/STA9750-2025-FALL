---
title: "Mini-Project #02: Making Backyards Affordable for All"
author: "Selena Li"
format:
  html:
    theme: cosmo
    toc: true
    toc-location: right
    toc-title: "Navigation"
    code-fold: true
    code-summary: "Show R Code"
    code-fold-default: hide
---

## Data Aquisition
```{r}
if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
    ## Mask base::library() to automatically install packages if needed
    ## Masking is important here so downlit picks up packages and links
    ## to documentation
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)
```

```{r}
get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()

# Building Permits — Total Units per Year (All CBSAs) [Clean version]

library(dplyr)
library(ggplot2)
library(scales)

permits_named <- PERMITS |>
left_join(POPULATION |> distinct(GEOID, NAME), by = c("CBSA" = "GEOID"))

permits_yearly <- permits_named |>
group_by(year) |>
summarize(total_permits = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop")

ggplot(permits_yearly, aes(x = year, y = total_permits)) +
geom_col(fill = "#4CAF50") +
scale_y_continuous(labels = label_comma()) +
scale_x_continuous(breaks = seq(min(permits_yearly$year), max(permits_yearly$year), 2)) +
labs(
title = "Building Permits — Total Units per Year (All CBSAs)",
x = "Year",
y = "Units permitted (count)"
) +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15),
axis.title = element_text(size = 12)
)

```

## Get BLS Industry Codes
```{r}
library(httr2)
library(rvest)
get_bls_industry_codes <- function(){
    fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    library(dplyr)
    library(tidyr)
    library(readr)
    
    if(!file.exists(fname)){
        
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        # These were looked up manually on bls.gov after finding 
        # they were presented as ranges. Since there are only three
        # it was easier to manually handle than to special-case everything else
        naics_missing <- tibble::tribble(
            ~Code, ~title, ~depth, 
            "31", "Manufacturing", 1,
            "32", "Manufacturing", 1,
            "33", "Manufacturing", 1,
            "44", "Retail", 1, 
            "45", "Retail", 1,
            "48", "Transportation and Warehousing", 1, 
            "49", "Transportation and Warehousing", 1
        )
        
        naics_table <- bind_rows(naics_table, naics_missing)
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code) |>
            drop_na() |>
            mutate(across(contains("code"), as.integer))
        
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

INDUSTRY_CODES <- get_bls_industry_codes()

# BLS NAICS Coverage — Top 8 sectors (concise, no regex, no %>%)

suppressPackageStartupMessages(library(ggplot2))

# 1) Count unique 4-digit industries per top-level sector

counts <- aggregate(level4_code ~ level1_title, INDUSTRY_CODES,
function(x) length(unique(x)))
names(counts) <- c("sector", "n")

# 2) Shorten long sector names using fixed-string replace (no regex)

map_from <- c(
"Transportation and Warehousing",
"Professional, scientific, and technical services",
"Administrative and support and waste management and remediation services",
"Management of companies and enterprises",
"Accommodation and food services",
"Agriculture, forestry, fishing and hunting",
"Health care and social assistance",
"Other services (except public administration)",
"Wholesale trade", "Retail trade", "Finance and insurance",
"Real estate and rental and leasing", "Public administration",
"Educational services"
)

map_to <- c(
"Transport & Warehousing",
"Prof/Sci/Tech Svcs",
"Admin & Waste Mgmt",
"Mgmt of Companies",
"Accommodation & Food",
"Agri/Forestry/Fishing",
"Health & Social",
"Other Svcs (excl public)",
"Wholesale", "Retail", "Finance & Insurance",
"Real Estate & Rental", "Public Admin",
"Education"
)

shorten_fixed <- function(x, from, to) {
for (i in seq_along(from)) x <- gsub(from[i], to[i], x, fixed = TRUE)
x
}
counts$label <- shorten_fixed(counts$sector, map_from, map_to)

# 3) Keep top 8 and order for plotting

idx <- order(-counts$n)
counts <- counts[idx, ]
if (nrow(counts) > 8) counts <- counts[1:8, ]
counts$label <- factor(counts$label, levels = rev(counts$label[order(counts$n)]))

# 4) Plot (compact)

ggplot(counts, aes(x = n, y = label)) +
geom_col(width = 0.7, fill = "#db9cd4") +
labs(title = "BLS NAICS Coverage — Top Sectors",
x = "4-digit industries (count)", y = NULL) +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 13))

```

## BLS Quarterly Census of Employment and Wages
```{r}
library(httr2)
library(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

# --- Safe read_csv wrapper for ZIPs (no regex, no backslashes to escape) ---
if (!requireNamespace("readr", quietly = TRUE)) install.packages("readr")
library(readr)

read_csv <- function(path, ...) {
  path <- as.character(path)
  low  <- tolower(path)
  if (endsWith(low, ".zip")) {
    td <- tempdir()
    extracted <- tryCatch(utils::unzip(path, exdir = td), error = function(e) character())
    # keep only CSV files
    csvs <- extracted[tolower(tools::file_ext(extracted)) == "csv"]
    if (length(csvs) == 0) stop("No CSV found inside ZIP: ", basename(path))
    return(readr::read_csv(csvs[1], ...))
  } else {
    return(readr::read_csv(path, ...))
  }
}

# (optional) if the combined cache exists but is corrupt, force rebuild
gzfile <- "data/mp02/bls_qcew_2009_2023.csv.gz"
if (file.exists(gzfile)) {
  ok <- TRUE
  tryCatch(readr::read_csv(gzfile, n_max = 5, show_col_types = FALSE),
           error = function(e) ok <<- FALSE)
  if (!ok) unlink(gzfile, force = TRUE)
}

# --- Clean bad/missing BLS cache for 2009 & 2010 (run once if you see the error) ---
bad_years <- c(2009, 2010)
zip_paths <- file.path("data", "mp02", paste0(bad_years, "_qcew_annual_singlefile.zip"))
combo_path <- file.path("data", "mp02", "bls_qcew_2009_2023.csv.gz")

for (z in zip_paths) if (file.exists(z)) unlink(z, force = TRUE)
if (file.exists(combo_path)) unlink(combo_path, force = TRUE)


WAGES <- get_bls_qcew_annual_averages()

# --- Compact visuals for BLS QCEW ---

suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(scales))

# 1) Time series: total employment by year

emp_year <- aggregate(EMPLOYMENT ~ YEAR, data = WAGES, sum, na.rm = TRUE)

ggplot(emp_year, aes(x = YEAR, y = EMPLOYMENT)) +
geom_line(linewidth = 1.1, color = "#4CAF50") +
geom_point(size = 1.6, color = "#4CAF50") +
scale_y_continuous(labels = label_comma()) +
scale_x_continuous(breaks = seq(min(emp_year$YEAR), max(emp_year$YEAR), 2)) +
labs(title = "QCEW — Total Employment (All CBSAs)",
x = "Year", y = "Employment (count)") +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 13))

# 2) Time series: average wage (total wages / employment)

tmp <- aggregate(cbind(TOTAL_WAGES, EMPLOYMENT) ~ YEAR, data = WAGES, sum, na.rm = TRUE)
avgw_year <- data.frame(YEAR = tmp$YEAR, AVG_WAGE = tmp$TOTAL_WAGES / tmp$EMPLOYMENT)

ggplot(avgw_year, aes(x = YEAR, y = AVG_WAGE)) +
geom_line(linewidth = 1.1, color = "#2196F3") +
geom_point(size = 1.6, color = "#2196F3") +
scale_y_continuous(labels = label_dollar()) +
scale_x_continuous(breaks = seq(min(avgw_year$YEAR), max(avgw_year$YEAR), 2)) +
labs(title = "QCEW — Average Wage (All CBSAs)",
x = "Year", y = "Average wage (USD)") +
theme_minimal(base_size = 12) +
theme(plot.title = element_text(face = "bold", size = 13))

# 3) Latest year — top 8 sectors by employment (level 1 NAICS)
# QCEW - Top sectors by employment (latest year, full names visible)

library(ggplot2)
library(scales)
library(stringr)

# latest year

latest <- max(WAGES$YEAR, na.rm = TRUE)

# map level-1 NAICS to sector names

sector_map <- INDUSTRY_CODES |>
dplyr::mutate(LEVEL1 = dplyr::coalesce(level1_title, "Other")) |>
dplyr::select(INDUSTRY = level1_code, SECTOR = LEVEL1) |>
dplyr::distinct()

# aggregate for latest year

w_latest <- WAGES |>
dplyr::filter(YEAR == latest) |>
dplyr::mutate(INDUSTRY = as.integer(substr(INDUSTRY, 1, 2))) |>
dplyr::group_by(INDUSTRY) |>
dplyr::summarise(EMPLOYMENT = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") |>
dplyr::left_join(sector_map, by = "INDUSTRY") |>
dplyr::group_by(SECTOR) |>
dplyr::summarise(EMPLOYMENT = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop") |>
dplyr::filter(!is.na(SECTOR)) |>
dplyr::slice_max(EMPLOYMENT, n = 8) |>
dplyr::arrange(EMPLOYMENT)

# wrap long names

w_latest$SECTOR <- str_wrap(w_latest$SECTOR, width = 30)

# plot

ggplot(w_latest, aes(x = EMPLOYMENT / 1e6, y = SECTOR)) +
geom_col(width = 0.7, fill = "#4CAF50") +
scale_x_continuous(labels = label_number(accuracy = 1, suffix = "M")) +
labs(
title = paste0("QCEW - Top Sectors by Employment (", latest, ")"),
x = "Employment (millions)",
y = NULL
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", size = 13),
axis.text.y = element_text(size = 10, lineheight = 1.1),
plot.margin = margin(10, 20, 10, 150)  # extra left margin for long labels
)

```


## Data Integration and Initial Expploration

We use `dplyr` joins and grouped summaries to explore relationships across ACS, BLS, and permits data.

**Q1 — Largest Number of New Housing Units Permitted (2010–2019)**

```{r}
library(dplyr)

permits_decade <- PERMITS |>
  filter(year >= 2010, year <= 2019) |>
  group_by(CBSA) |>
  summarize(total_units = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop")

top_cbsa <- permits_decade |>
  slice_max(total_units, n = 1) |>
  left_join(unique(POPULATION[, c("GEOID", "NAME")]), by = c("CBSA" = "GEOID"))

top_cbsa
```

**Q2 — Year Albuquerque (10740) Permitted the Most Units**
```{r}
permits_alb <- PERMITS |>
filter(CBSA == 10740, year != 2020) |>
group_by(year) |>
summarize(total_units = sum(new_housing_units_permitted, na.rm = TRUE), .groups = "drop") |>
slice_max(total_units, n = 1)

permits_alb
```

**Q3-State with Highest Average Individual Income (2015)**
```{r}
income_state <- INCOME |>
filter(year == 2015) |>
left_join(HOUSEHOLDS |> filter(year == 2015), by = c("GEOID", "NAME")) |>
left_join(POPULATION |> filter(year == 2015), by = c("GEOID", "NAME")) |>
mutate(total_income = household_income * households,
state = str_extract(NAME, ", (.{2})", group = 1)) |>
group_by(state) |>
summarize(state_income = sum(total_income, na.rm = TRUE),
state_pop = sum(population, na.rm = TRUE),
avg_individual_income = state_income / state_pop,
.groups = "drop") |>
slice_max(avg_individual_income, n = 1)

income_state
```


**Q4 — Last Year NYC Had Most Data Scientists (NAICS 5182)**
```{r}

CENSUS_CBSA <- POPULATION |>
transmute(std_cbsa = paste0("C", GEOID), NAME, year)

BLS_DS <- WAGES |>
filter(INDUSTRY == 5182) |>
mutate(std_cbsa = paste0(FIPS, "0")) |>
group_by(std_cbsa, YEAR) |>
summarize(EMPLOYMENT = sum(EMPLOYMENT, na.rm = TRUE), .groups = "drop")

ds_yearly_leaders <- BLS_DS |>
slice_max(EMPLOYMENT, by = YEAR, n = 1) |>
left_join(CENSUS_CBSA, by = "std_cbsa") |>
select(YEAR, NAME, EMPLOYMENT)

nyc_last <- ds_yearly_leaders |>
filter(str_detect(NAME, "New York")) |>
slice_tail(n = 1)

nyc_last
```

**Q5 — Fraction of Total Wages in Finance (NAICS 52) for NYC CBSA**
```{r}
finance_share <- WAGES |>
mutate(std_cbsa = paste0(FIPS, "0")) |>
left_join(POPULATION |> transmute(std_cbsa = paste0("C", GEOID), NAME), by = "std_cbsa") |>
filter(str_detect(NAME, "New York")) |>
group_by(YEAR) |>
summarize(
total_wages_all = sum(TOTAL_WAGES, na.rm = TRUE),
total_wages_fin = sum(TOTAL_WAGES[INDUSTRY == 52], na.rm = TRUE),
share_finance = total_wages_fin / total_wages_all,
.groups = "drop"
)

finance_peak <- finance_share |> slice_max(share_finance, n = 1)

finance_peak
```

## Initial Visualizations
**Monthly Rent vs. Household Income per CBSA (2009)**
```{r}
# Cleaner, non-overlapping legend version
library(ggplot2)
library(scales)
library(viridisLite)  # viridis colors
library(grid)         # for unit()

rent_income_2009 <- INCOME |>
  dplyr::filter(year == 2009) |>
  dplyr::select(GEOID, NAME, household_income) |>
  dplyr::left_join(
    RENT |> dplyr::filter(year == 2009) |> dplyr::select(GEOID, NAME, monthly_rent),
    by = c("GEOID", "NAME")
  )

ggplot(rent_income_2009,
       aes(x = household_income,
           y = monthly_rent,
           color = household_income,
           size  = monthly_rent)) +
  geom_point(alpha = 0.85) +
  # axes
  scale_x_continuous(labels = label_dollar()) +
  scale_y_continuous(labels = label_dollar()) +
  # color bar: fewer, formatted breaks
  scale_color_viridis_c(
    name   = "Household Income (USD)",
    option = "C", direction = -1,
    breaks = pretty_breaks(4),
    labels = label_dollar()
  ) +
  # size legend: few labeled sizes
  scale_size(
    name   = "Monthly Rent (USD)",
    range  = c(1.8, 7),
    breaks = pretty_breaks(3),
    labels = label_dollar()
  ) +
  labs(
    title    = "Monthly Rent vs Household Income by CBSA (2009)",
    subtitle = "Each dot is a CBSA",
    x = "Average Household Income (USD)",
    y = "Median Monthly Rent (USD)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position    = "bottom",
    legend.box         = "vertical",
    legend.title       = element_text(size = 11),
    legend.text        = element_text(size = 10),
    panel.grid.minor   = element_blank(),
    plot.title         = element_text(face = "bold")
  ) +
  guides(
    color = guide_colorbar(
      title.position = "top", label.position = "bottom",
      barwidth = unit(7, "cm"), barheight = unit(0.35, "cm"),
      ticks = FALSE
    ),
    size = guide_legend(
      title.position = "top", label.position = "bottom",
      override.aes = list(alpha = 0.9),
      nrow = 1
    )
  )
```


**Evolution of Average Household Size Over Time (by CBSA)**
```{r}
# Multi-row legend + clearer colors + wrapped labels
library(dplyr)
library(ggplot2)
library(scales)
library(stringr)

hh_size <- POPULATION |>
  select(GEOID, year, population) |>
  left_join(HOUSEHOLDS |> select(GEOID, year, households),
            by = c("GEOID","year")) |>
  mutate(avg_household_size = population / households)

cbsa_names <- POPULATION |>
  group_by(GEOID) |>
  slice_max(year, n = 1, with_ties = FALSE) |>
  ungroup() |>
  select(GEOID, NAME)

# keep 12 popular CBSAs (or adjust n)
top_geoids <- hh_size |>
  group_by(GEOID) |>
  summarize(median_pop = median(population, na.rm = TRUE), .groups = "drop") |>
  slice_max(median_pop, n = 12) |>
  pull(GEOID)

hh_plot <- hh_size |>
  filter(GEOID %in% top_geoids) |>
  left_join(cbsa_names, by = "GEOID") |>
  mutate(NAME_wrapped = str_wrap(NAME, 28))  # wrap long labels to avoid truncation

ggplot(hh_plot, aes(x = year, y = avg_household_size,
                    color = NAME_wrapped, group = NAME_wrapped)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.8) +
  scale_x_continuous(breaks = seq(2009, 2023, 2)) +
  scale_y_continuous(labels = label_number(accuracy = 0.1)) +
  scale_color_brewer(palette = "Set3", name = "CBSA") +  # 12 distinct colors
  labs(
    title = "Evolution of Average Household Size Over Time (Selected CBSAs)",
    x = "Year",
    y = "Average Household Size"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    legend.box = "vertical",
    legend.text = element_text(size = 9),
    legend.key.width  = grid::unit(0.7, "cm"),
    legend.key.height = grid::unit(0.4, "cm"),
    plot.margin = margin(10, 10, 70, 10)  # extra space for multi-row legend
  ) +
  guides(
    color = guide_legend(
      nrow = 4, byrow = TRUE,   # <-- make more than 2 rows
      title.position = "top",
      label.hjust = 0
    )
  )
```

## Building Indices of Housing Affordability and Housing Stock Growth

**Rent Burden**
```{r}
# Task 4 — Rent Burden metric + two DT tables (self-contained)

library(dplyr)
library(DT)

# --- Build rent_burden --------------------------------------------------
rent_burden <- INCOME |>
  select(GEOID, NAME, year, household_income) |>
  inner_join(
    RENT |> select(GEOID, NAME, year, monthly_rent),
    by = c("GEOID","NAME","year")
  ) |>
  mutate(
    rent_to_income_pct = 100 * (monthly_rent * 12) / household_income
  )

# Standardizations
nat_avg    <- mean(rent_burden$rent_to_income_pct, na.rm = TRUE)
first_year <- min(rent_burden$year, na.rm = TRUE)
first_avg  <- rent_burden |>
  filter(year == first_year) |>
  summarize(v = mean(rent_to_income_pct, na.rm = TRUE)) |>
  pull(v)
rng <- range(rent_burden$rent_to_income_pct, na.rm = TRUE)

rent_burden <- rent_burden |>
  mutate(
    rent_burden_index_100avg  = rent_to_income_pct / nat_avg  * 100,
    rent_burden_index_firstyr = rent_to_income_pct / first_avg * 100,
    rent_burden_minmax        = (rent_to_income_pct - rng[1]) / (rng[2] - rng[1]) * 100
  )

# --- Table 1: One CBSA over time ---------------------------------------
selected_cbsa <- "New York-Newark-Jersey City, NY-NJ Metro Area"

rb_selected <- rent_burden |>
  filter(NAME == selected_cbsa) |>
  arrange(year) |>
  transmute(
    Year                     = year,
    `Household income (USD)` = household_income,
    `Monthly rent (USD)`     = monthly_rent,
    `Rent-to-income (%)`     = rent_to_income_pct,
    `Index (100 = nat avg)`  = rent_burden_index_100avg,
    `Index (100 = first yr)` = rent_burden_index_firstyr,
    `Scaled (0–100)`         = rent_burden_minmax
  )

datatable(
  rb_selected,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: center; font-weight: bold;",
    paste0("Rent Burden Over Time — ", selected_cbsa)
  ),
  options = list(pageLength = 10, autoWidth = TRUE, dom = "tip",
                 order = list(list(0, "asc"))),
  rownames = FALSE
) |>
  formatCurrency(c("Household income (USD)", "Monthly rent (USD)"), "$", digits = 0) |>
  formatRound(c("Rent-to-income (%)", "Index (100 = nat avg)",
                "Index (100 = first yr)", "Scaled (0–100)"), 1)

# --- Table 2: Highest & Lowest in latest year ---------------------------
metric_col <- "rent_to_income_pct"   # change to "rent_burden_index_100avg" or "rent_burden_minmax" if preferred
latest_year <- max(rent_burden$year, na.rm = TRUE)

rb_latest <- rent_burden |>
  filter(year == latest_year) |>
  mutate(.metric = .data[[metric_col]])

top_n <- 10
rb_extremes <- bind_rows(
  rb_latest |> arrange(desc(.metric)) |> slice_head(n = top_n) |> mutate(`Rank group` = "Highest"),
  rb_latest |> arrange(.metric)       |> slice_head(n = top_n) |> mutate(`Rank group` = "Lowest")
) |>
  transmute(
    `Rank group`,
    CBSA                      = NAME,
    Year                      = year,
    `Monthly rent (USD)`      = monthly_rent,
    `Household income (USD)`  = household_income,
    `Rent-to-income (%)`      = rent_to_income_pct,
    `Index (100 = nat avg)`   = rent_burden_index_100avg,
    `Index (100 = first yr)`  = rent_burden_index_firstyr,
    `Scaled (0–100)`          = rent_burden_minmax
  )

datatable(
  rb_extremes,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: center; font-weight: bold;",
    paste0("Metro Areas with Highest and Lowest Rent Burden — ", latest_year,
           " (metric: ", metric_col, ")")
  ),
  options = list(pageLength = 20, autoWidth = TRUE, dom = "ftip",
                 order = list(list(0, "asc"))),
  filter = "top",
  rownames = FALSE
) |>
  formatCurrency(c("Monthly rent (USD)", "Household income (USD)"), "$", digits = 0) |>
  formatRound(c("Rent-to-income (%)", "Index (100 = nat avg)",
                "Index (100 = first yr)", "Scaled (0–100)"), 1)
```


**Housing Growth**
```{r}
# Task 5 — Build housing_growth, standardize, roll, and show two DT tables (self-contained)

library(dplyr)
library(DT)
library(scales)
library(zoo)

## --- Build housing_growth from POPULATION + PERMITS --------------------
pop_cbsa <- POPULATION |>
  mutate(cbsa_code = as.integer(GEOID)) |>
  select(cbsa_code, NAME, year, population)

permits_cbsa <- PERMITS |>
  rename(cbsa_code = CBSA, permits = new_housing_units_permitted) |>
  select(cbsa_code, year, permits)

pop_permits <- pop_cbsa |>
  inner_join(permits_cbsa, by = c("cbsa_code", "year"))

housing_growth <- pop_permits |>
  arrange(cbsa_code, year) |>
  group_by(cbsa_code) |>
  mutate(
    population_5y_ago = lag(population, 5),
    pop_growth_5y_abs = population - population_5y_ago,
    pop_growth_5y_pct = 100 * (population - population_5y_ago) / population_5y_ago
  ) |>
  ungroup() |>
  mutate(
    # Instantaneous metric: permits per 1,000 residents
    hg_instant_per_1k  = 1000 * permits / population,
    # Rate-based metric: permits per 100 new residents over prior 5 years
    hg_rate_per_100_new = ifelse(pop_growth_5y_abs > 0,
                                 100 * permits / pop_growth_5y_abs,
                                 NA_real_)
  )

## --- Standardize (0–100) and composite --------------------------------
hg_std <- housing_growth |>
  mutate(
    hg_instant_scaled = rescale(hg_instant_per_1k,  to = c(0, 100), na.rm = TRUE),
    hg_rate_scaled    = rescale(hg_rate_per_100_new, to = c(0, 100), na.rm = TRUE),
    composite_score   = 0.5 * hg_instant_scaled + 0.5 * hg_rate_scaled
  )

## --- 5-year right-aligned rolling averages (smoother) ------------------
hg_roll <- hg_std |>
  group_by(cbsa_code) |>
  arrange(year, .by_group = TRUE) |>
  mutate(
    hg_instant_roll5 = zoo::rollmean(hg_instant_scaled, 5, fill = NA, align = "right"),
    hg_rate_roll5    = zoo::rollmean(hg_rate_scaled,    5, fill = NA, align = "right"),
    composite_roll5  = zoo::rollmean(composite_score,   5, fill = NA, align = "right")
  ) |>
  ungroup()

## --- Table A: one CBSA over time --------------------------------------
selected_cbsa <- "New York-Newark-Jersey City, NY-NJ Metro Area"

tbl_cbsa <- hg_roll |>
  filter(NAME == selected_cbsa) |>
  arrange(year) |>
  select(
    Year = year,
    Population = population,
    Permits = permits,
    `Instantaneous (per 1,000)` = hg_instant_per_1k,
    `Rate-based (per 100 new)`  = hg_rate_per_100_new,
    `Instantaneous (0–100)`     = hg_instant_scaled,
    `Rate-based (0–100)`        = hg_rate_scaled,
    `Composite (0–100)`         = composite_score,
    `Composite roll-5 (0–100)`  = composite_roll5
  )

datatable(
  tbl_cbsa,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: center; font-weight: bold;",
    paste0("Housing Growth Over Time — ", selected_cbsa)
  ),
  options = list(pageLength = 10, autoWidth = TRUE, dom = "tip", scrollX = TRUE),
  rownames = FALSE
) |>
  formatCurrency(c("Population", "Permits"), currency = "", digits = 0) |>
  formatRound(c("Instantaneous (per 1,000)", "Rate-based (per 100 new)"), 1) |>
  formatRound(c("Instantaneous (0–100)", "Rate-based (0–100)",
                "Composite (0–100)", "Composite roll-5 (0–100)"), 1)

## --- Table B: Top & Bottom CBSAs (latest year, rolling composite) ------
latest_year <- max(hg_roll$year, na.rm = TRUE)

rank_base <- hg_roll |>
  filter(year == latest_year, !is.na(composite_roll5)) |>
  select(
    CBSA = NAME, Year = year, Population = population, Permits = permits,
    `Instantaneous (per 1,000)` = hg_instant_per_1k,
    `Rate-based (per 100 new)`  = hg_rate_per_100_new,
    `Composite (0–100)`         = composite_score,
    `Composite roll-5 (0–100)`  = composite_roll5
  )

top_n <- 10
tbl_top_bottom <- bind_rows(
  rank_base |> arrange(desc(`Composite roll-5 (0–100)`)) |> slice_head(n = top_n) |> mutate(`Rank group` = "Highest"),
  rank_base |> arrange(     `Composite roll-5 (0–100)`)  |> slice_head(n = top_n) |> mutate(`Rank group` = "Lowest")
) |>
  relocate(`Rank group`)

datatable(
  tbl_top_bottom,
  caption = htmltools::tags$caption(
    style = "caption-side: top; text-align: center; font-weight: bold;",
    paste0("Top & Bottom CBSAs by Housing Growth (Rolling Composite) — ", latest_year)
  ),
  options = list(pageLength = 20, autoWidth = TRUE, dom = "ftip", scrollX = TRUE),
  filter = "top",
  rownames = FALSE
) |>
  formatCurrency(c("Population", "Permits"), currency = "", digits = 0) |>
  formatRound(c("Instantaneous (per 1,000)", "Rate-based (per 100 new)",
                "Composite (0–100)", "Composite roll-5 (0–100)"), 1)
```

**Visualization**
```{r, warning=FALSE, message=FALSE}
# Task 6 — YIMBY Visualization (Final Polished Version)
# Combines rent burden & housing growth analysis

library(dplyr)
library(ggplot2)
library(scales)
library(ggrepel)

# Assumptions:
# rent_burden: GEOID, NAME, year, rent_to_income_pct
# housing_growth: cbsa_code, NAME, year, hg_instant_per_1k, pop_growth_5y_pct

# 1️⃣ Build summary data ----------------------------------

latest_year <- min(
  max(rent_burden$year, na.rm = TRUE),
  max(housing_growth$year, na.rm = TRUE)
)

# Rent burden early vs late (by CBSA)
rb_summ <- rent_burden |>
  group_by(NAME) |>
  summarise(
    rb_early = mean(rent_to_income_pct[year <= 2012], na.rm = TRUE),
    rb_late  = mean(rent_to_income_pct[year >= latest_year - 2], na.rm = TRUE),
    rb_change = rb_late - rb_early,
    .groups = "drop"
  )

# Housing growth summary (by CBSA)
hg_summ <- housing_growth |>
  group_by(NAME) |>
  summarise(
    avg_housing_growth = mean(hg_instant_per_1k, na.rm = TRUE),
    avg_pop_growth = mean(pop_growth_5y_pct, na.rm = TRUE),
    .groups = "drop"
  )

# Combine rent & housing metrics
summary_df <- rb_summ |>
  inner_join(hg_summ, by = "NAME") |>
  filter(!is.na(rb_change), !is.na(avg_housing_growth))

# Identify top “YIMBY” CBSAs (high housing growth, decreasing rent burden)
top_yimby <- summary_df |>
  filter(rb_change < 0, avg_housing_growth > median(avg_housing_growth, na.rm = TRUE)) |>
  arrange(rb_change) |>
  slice_head(n = 5)

# 2️⃣ Visualization 1: Rent Burden vs Housing Growth -----------------

ggplot(summary_df, aes(
  x = avg_housing_growth,
  y = rb_change,
  color = avg_pop_growth,
  size = abs(avg_pop_growth)
)) +
  geom_point(alpha = 0.7) +
  geom_text_repel(
    data = subset(summary_df, NAME %in% top_yimby$NAME),
    aes(label = NAME),
    size = 3.2, max.overlaps = 30
  ) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = median(summary_df$avg_housing_growth, na.rm = TRUE), linetype = "dotted") +
  scale_color_gradient2(low = "blue", mid = "gray80", high = "red", midpoint = 0, name = "Population growth (%)") +
  scale_size_continuous(range = c(1, 10), guide = "none") +
  labs(
    title = "Rent Burden Change vs Housing Growth",
    subtitle = "Right = higher housing growth; Below 0 = decreasing rent burden",
    x = "Average housing growth (permits per 1,000 residents)",
    y = "Change in rent burden (late − early)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    legend.position = "bottom",
    legend.box = "vertical",
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 10)
  )

# 3️⃣ Visualization 2: Rent Burden Over Time for Top 5 CBSAs -----------------

rent_burden |>
  filter(NAME %in% top_yimby$NAME) |>
  ggplot(aes(x = year, y = rent_to_income_pct, color = NAME)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.8) +
  labs(
    title = "Top 5 Candidate 'YIMBY' CBSAs — Rent Burden Over Time",
    subtitle = "High early burden, decreasing burden, positive population growth, high housing growth",
    x = "Year",
    y = "Rent burden (% of income)",
    color = "CBSA"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 15),
    legend.position = "bottom",
    legend.box = "vertical",
    legend.key.size = unit(0.6, "cm"),
    legend.text = element_text(size = 9),
    legend.title = element_text(size = 10),
    legend.spacing.y = unit(0.3, "cm"),
    legend.box.spacing = unit(0.3, "cm"),
    legend.key.width = unit(1.2, "cm"),
    legend.justification = "center"
  ) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE))
```

## Policy Brief
**Objective**
Create a federal incentive program that rewards municipalities for adopting YIMBY policies that expand housing supply, lower rent burdens, and support job growth.

**Sponsors (Hometowns)**
1. Primary Sponsor: Representative from Houston, TX (CBSA) — sustained permitting, steady population gains, easing rent burdens.
2. Co-Sponsor: Representative from New York, NY (CBSA) — high rents, low permitting; clear need for supply-side incentives.

**Why This Pair**
1. Houston = proof of concept: Flexible zoning + infrastructure coordination → abundant supply and moderated rents.
2. New York = high-impact need: Restrictive zoning → high rents, long commutes, slower housing growth.
3. Result: Bipartisan credibility (success case + need case).

**Key Allies (Labor & Industry)**
1. Construction & Building Trades: Streamlined approvals → steadier projects, more apprenticeships, safer sites.
2. Teachers & Public Safety Workers: Lower rent burden → closer to workplaces, better retention, improved coverage.

**Voter Benefits (By Occupation)**
1. Construction: More projects and training slots; higher local spending as rent share falls.
2. Teachers/Public Safety: Reduced rent burden and commute times; greater neighborhood stability and service reliability.

**Program Metrics (Plain English)**
1. Rent Burden Index (RBI): Share of median income spent on rent. Lower = better affordability.
2. Housing Growth Score (HGS): Combines (1) permits per 1,000 residents and (2) permits relative to 5-year population growth. Higher = better supply response.

**Local Talking Points**
1. Houston: Federal funds would reward ongoing success, support infrastructure, and expand skilled-trade training.
2. New York: Incentives would unlock more homes near transit, reduce rent pressure, and shorten commutes.

**Evidence Base**
ACS (income, rent, population), Census Building Permits Survey (new units), BLS QCEW (employment/wages). These sources support rent-burden comparisons, housing-growth measures, and occupation employment counts.

