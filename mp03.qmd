---
title: "Mini Project 3 — Visualizing and Maintaining the Green Canopy of NYC"
author: "Selena Li"
format:
  html:
    theme: sandstone
    toc: true
    toc-location: right
    toc-title: "Navigation"
    code-fold: true
    code-summary: "Show R Code"
    code-fold-default: hide
    number-sections: true
---

# NYC City Council Districts
## Task 1: Download NYC City Council District Boundaries

```{r, message=FALSE, warning=FALSE}
download_cc_districts <- function(
  data_dir   = "data/mp03",
  zip_url    = "https://data.cityofnewyork.us/api/geospatial/mkqi-d8x3?method=export&format=Shapefile",
  simplify   = FALSE,
  dTolerance = 5   # meters; only used if simplify = TRUE
) {
  # Ensure directory exists
  dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
  
  # Local paths
  zip_path  <- file.path(data_dir, "nyc_city_council.zip")
  unzip_dir <- file.path(data_dir, "nyc_city_council")
  
  # Download ZIP only if not present
  if (!file.exists(zip_path)) {
    message("Downloading City Council districts shapefile...")
    download.file(
      url      = zip_url,
      destfile = zip_path,
      mode     = "wb"
    )
  } else {
    message("Using existing City Council ZIP file from ", zip_path)
  }
  
  # Unzip only if not already unzipped
  if (!dir.exists(unzip_dir)) {
    message("Unzipping shapefile into ", unzip_dir)
    unzip(zip_path, exdir = unzip_dir)
  }
  
  # Find the .shp file
  shp_files <- list.files(
    unzip_dir,
    pattern    = "\\.shp$",
    full.names = TRUE,
    recursive  = TRUE
  )
  
  if (length(shp_files) == 0) {
    stop("No .shp file found after unzipping – please check ZIP contents.")
  }
  
  # Read and transform to WGS84
  council_sf <- sf::st_read(shp_files[1], quiet = TRUE) |>
    sf::st_transform(crs = "WGS84")
  
  # Optional simplification
  if (simplify) {
    council_sf <- council_sf |>
      dplyr::mutate(
        geometry = sf::st_simplify(geometry, dTolerance = dTolerance)
      )
  }
  
  council_sf
}

# Call for Task 1:
council_districts <- download_cc_districts()
```

```{r fig.width=6.5, fig.height=5, message=FALSE, warning=FALSE}
# Add borough names based on district number
council_districts_plot <- council_districts |>
  dplyr::mutate(
    borough = dplyr::case_when(
      coun_dist >=  1 & coun_dist <= 10 ~ "Manhattan",
      coun_dist >= 11 & coun_dist <= 18 ~ "Bronx",
      coun_dist >= 19 & coun_dist <= 32 ~ "Queens",
      coun_dist >= 33 & coun_dist <= 48 ~ "Brooklyn",
      coun_dist >= 49 & coun_dist <= 51 ~ "Staten Island",
      TRUE                              ~ "Other"
    )
  )

ggplot2::ggplot(council_districts_plot) +
  ggplot2::geom_sf(
    ggplot2::aes(fill = borough),
    color = "white",
    linewidth = 0.2
  ) +
  ggplot2::scale_fill_brewer(palette = "Set2", name = "Borough") +
  ggplot2::labs(
    title = "NYC City Council Districts by Borough",
    subtitle = "Task 1: Downloaded from NYC Open Data and plotted with sf + ggplot2"
  ) +
  ggplot2::theme_minimal(base_size = 11) +
  ggplot2::theme(
    panel.grid.major = ggplot2::element_line(color = "grey90", linewidth = 0.2),
    panel.background = ggplot2::element_rect(fill = "grey98", color = NA),
    legend.position = "right"
  )
```

## Task 2: Download Tree Points
```{r}
download_tree_points <- function(
  data_dir  = "data/mp03",
  base_url  = "https://data.cityofnewyork.us/resource/hn5i-inap.geojson",
  limit     = 50000,      # number of rows per page
  sample_n  = NULL        # optional: use a subset while developing
) {
  # Ensure directory exists
  dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
  
  # Consistent naming pattern for cached GeoJSON pages
  file_pattern <- "^treepoints_\\d+\\.geojson$"
  
  # Check for cached files first
  existing_files <- list.files(
    data_dir,
    pattern = file_pattern,
    full.names = TRUE
  )
  
  # Only hit the API if no local files yet
  if (length(existing_files) == 0) {
    offset <- 0L
    page   <- 1L
    
    repeat {
      message(sprintf("Requesting page %d (offset = %d)...", page, offset))
      
      # Build httr2 request with limit + offset
      req <- httr2::request(base_url) |>
        httr2::req_url_query(
          "$limit"  = limit,
          "$offset" = offset
        )
      
      resp <- httr2::req_perform(req)
      raw  <- httr2::resp_body_raw(resp)
      
      # Save this page as a GeoJSON file
      destfile <- file.path(
        data_dir,
        sprintf("treepoints_%03d.geojson", page)
      )
      writeBin(raw, destfile)
      
      # Use JSON to check how many features were returned
      geo <- jsonlite::fromJSON(rawToChar(raw))
      n   <- length(geo$features)
      message(sprintf("  -> Retrieved %d tree points.", n))
      
      # Stopping rule: stop when fewer than limit points returned
      if (n < limit) break
      
      offset <- offset + limit
      page   <- page + 1L
    }
    
    # Refresh list after downloading
    existing_files <- list.files(
      data_dir,
      pattern = file_pattern,
      full.names = TRUE
    )
  } else {
    message("Using cached tree point files in ", data_dir)
  }
  
  # Read every saved GeoJSON page as sf
  tree_sf_list <- purrr::map(
    existing_files,
    ~ sf::st_read(.x, quiet = TRUE)
  )
  
  # Combine pages
  tree_points <- dplyr::bind_rows(tree_sf_list)
  
  # Ensure WGS84 CRS
  tree_points <- sf::st_transform(tree_points, crs = "WGS84")
  
  # Optional small subset for speed
  if (!is.null(sample_n)) {
    tree_points <- tree_points |>
      dplyr::slice_sample(n = min(sample_n, nrow(tree_points)))
  }
  
  return(tree_points)
}
```

```{r, message=FALSE, warning=FALSE, results='hide'}
# Download + cache the tree data once
tree_points <- download_tree_points()
```

```{r fig.width=7, fig.height=4.5, message=FALSE, warning=FALSE}
# Drop geometry and summarise tree condition
tree_points_summary <- tree_points |>
  sf::st_drop_geometry() |>
  dplyr::count(tpcondition, name = "n_trees") |>
  dplyr::mutate(
    tpcondition = forcats::fct_reorder(tpcondition, n_trees)
  )

ggplot2::ggplot(
  tree_points_summary,
  ggplot2::aes(x = n_trees, y = tpcondition, fill = tpcondition)
) +
  ggplot2::geom_col() +
  ggplot2::scale_fill_brewer(palette = "Spectral", name = "Condition", na.value = "grey70") +
  ggplot2::labs(
    title    = "Distribution of NYC Street Trees by Condition",
    subtitle = "Task 2: Based on downloaded NYC Forestry Tree Points",
    x        = "Number of trees",
    y        = "Tree condition"
  ) +
  ggplot2::theme_minimal(base_size = 11) +
  ggplot2::theme(
    legend.position  = "none",
    panel.grid.major = ggplot2::element_line(color = "grey90", linewidth = 0.2)
  )
```

# Data Integration and Initial Exploration
## Mappinf NYC Trees

## Task 3: Plot ALl Tree Points
```{r}
## 3.1 Mapping NYC Trees – initial summary plot
tree_points_summary <- tree_points |>
  sf::st_drop_geometry() |>
  dplyr::count(tpcondition) |>
  dplyr::mutate(
    tpcondition = forcats::fct_reorder(tpcondition, n)  # order by count
  )

ggplot2::ggplot(
  tree_points_summary,
  ggplot2::aes(x = n, y = tpcondition, fill = tpcondition)
) +
  ggplot2::geom_col() +
  ggplot2::scale_fill_brewer(palette = "Set1", na.value = "grey60") +
  ggplot2::labs(
    title = "Distribution of NYC Street Trees by Condition",
    x     = "Number of trees",
    y     = "Tree condition",
    fill  = "Condition"
  ) +
  ggplot2::theme_minimal(base_size = 11)
```

```{r}
### 3.2 – Map of tree points
tree_points_small <- tree_points |>
  dplyr::slice_sample(n = 20000) |>
  dplyr::mutate(
    tpcondition = factor(
      tpcondition,
      levels = c("Excellent", "Good", "Fair", "Poor", "Critical", "Dead", "Unknown")
    )
  )

ggplot2::ggplot() +
  ggplot2::geom_sf(
    data  = council_districts,
    fill  = "white",
    color = "green",
    linewidth = 0.3
  ) +
  ggplot2::geom_sf(
    data  = tree_points_small,
    ggplot2::aes(color = tpcondition),
    size  = 0.4,
    alpha = 0.6
  ) +
  ggplot2::coord_sf() +
  ggplot2::labs(
    title    = "NYC Street Trees by Condition",
    subtitle = "Sample of 20,000 trees over City Council Districts",
    color    = "Tree condition",
    caption  = "Data: NYC Forestry Tree Points & NYC City Council Districts"
  ) +
  ggplot2::guides(
    color = ggplot2::guide_legend(
      override.aes = list(size = 3, alpha = 1)
    )
  ) +
  ggplot2::theme_minimal(base_size = 11) +
  ggplot2::theme(
    panel.background = ggplot2::element_rect(fill = "grey98", color = NA),
    panel.grid.major = ggplot2::element_line(linewidth = 0.1, color = "grey90")
  )
```

# Extra Credit #1: Interactive Tree Map
```{r, message=FALSE, warning=FALSE}
# Extra Credit Interactive Tree Map

library(leaflet)
library(dplyr)

# For performance, sample 20k trees

tree_points_ec <- tree_points |>
dplyr::slice_sample(n = 20000)

# Color palette for tree condition

pal_cond <- colorFactor(
palette = "Set1",
domain  = tree_points_ec$tpcondition,
na.color = "gray70"
)

leaflet() |>
addProviderTiles(leaflet::providers$CartoDB.Positron) |>

# Add NYC Council District outlines

addPolygons(
data  = council_districts,
color = "#006d2c",
weight = 1,
fill = FALSE,
group = "Council Districts"
) |>

# Add tree clusters

addCircleMarkers(
data = tree_points_ec,
radius = 4,
stroke = FALSE,
fillOpacity = 0.7,
color = ~pal_cond(tpcondition),
popup = ~paste0(
"<b>Condition:</b> ", tpcondition, "<br>",
"<b>Species:</b> ", genusspecies, "<br>",
"<b>DBH:</b> ", dbh
),
clusterOptions = markerClusterOptions()
) |>

# Legend

addLegend(
position = "bottomright",
pal = pal_cond,
values = tree_points_ec$tpcondition,
title = "Tree Condition"
)
```

## Task 4: District-Level Analysis of Tree Coverage
```{r, results='asis'}
library(glue)

# 4.0 Spatial join: attach council district info to each tree
tree_district <- sf::st_join(
  tree_points,
  council_districts,
  join = sf::st_intersects,
  left = TRUE
)

# 4.1 District with the most trees
trees_by_district <- tree_district |>
  sf::st_drop_geometry() |>
  dplyr::count(coun_dist, name = "n_trees")

most_trees <- trees_by_district |>
  dplyr::slice_max(n_trees, n = 1)

# 4.2 District with highest tree density (trees per sq km)
district_area <- council_districts |>
  sf::st_drop_geometry() |>
  dplyr::select(coun_dist, shape_area)

tree_density <- trees_by_district |>
  dplyr::left_join(district_area, by = "coun_dist") |>
  dplyr::mutate(
    area_km2      = shape_area / 1e6,           # assuming area is in m^2
    trees_per_km2 = n_trees / area_km2
  )

highest_density <- tree_density |>
  dplyr::slice_max(trees_per_km2, n = 1)

# 4.3 District with highest fraction of dead trees
dead_fraction <- tree_district |>
  sf::st_drop_geometry() |>
  dplyr::group_by(coun_dist) |>
  dplyr::summarise(
    n_total   = dplyr::n(),
    n_dead    = sum(tpcondition == "Dead", na.rm = TRUE),
    frac_dead = n_dead / n_total,
    .groups   = "drop"
  ) |>
  dplyr::slice_max(frac_dead, n = 1)

# 4.4 Most common tree species in Manhattan
tree_with_boro <- tree_district |>
  sf::st_drop_geometry() |>
  dplyr::mutate(
    borough = dplyr::case_when(
      coun_dist >=  1 & coun_dist <= 10 ~ "Manhattan",
      coun_dist >= 11 & coun_dist <= 18 ~ "Bronx",
      coun_dist >= 19 & coun_dist <= 32 ~ "Queens",
      coun_dist >= 33 & coun_dist <= 48 ~ "Brooklyn",
      coun_dist >= 49 & coun_dist <= 51 ~ "Staten Island",
      TRUE                              ~ NA_character_
    )
  )

manhattan_top <- tree_with_boro |>
  dplyr::filter(borough == "Manhattan") |>
  dplyr::count(genusspecies, name = "n_trees") |>
  dplyr::slice_max(n_trees, n = 1)

# 4.5 Species of tree closest to Baruch

new_st_point <- function(lat, lon) {
  sf::st_sfc(sf::st_point(c(lon, lat)), crs = "WGS84")
}

baruch_point <- new_st_point(lat = 40.7403, lon = -73.9830)

# Distance in US survey feet (CRS 2263); convert to meters
tree_proj   <- sf::st_transform(tree_points, 2263)
baruch_proj <- sf::st_transform(baruch_point, 2263)

closest_tree <- tree_proj |>
  dplyr::mutate(distance_ft = sf::st_distance(geometry, baruch_proj)) |>
  dplyr::slice_min(distance_ft, n = 1) |>
  sf::st_drop_geometry()

dist_ft <- as.numeric(closest_tree$distance_ft)
dist_m  <- dist_ft * 0.3048

# ---- Nicely formatted markdown bullets ----
cat(glue("
- The council district with the **most trees** is **District {most_trees$coun_dist}**, with **{most_trees$n_trees}** trees.
- The **highest tree density** is in **District {highest_density$coun_dist}**, with about **{round(highest_density$trees_per_km2, 1)} trees per square kilometer**.
- **District {dead_fraction$coun_dist}** has the **highest fraction of dead trees**: **{round(100 * dead_fraction$frac_dead, 1)}%** ({dead_fraction$n_dead} out of {dead_fraction$n_total}).
- In **Manhattan**, the most common species is **{manhattan_top$genusspecies}** with **{manhattan_top$n_trees}** trees.
- The tree **closest to Baruch's campus** is **{closest_tree$genusspecies}**, located about **{round(dist_ft, 0)} feet (~{round(dist_m, 0)} meters)** away.
"))
```


## Task 5: District-Level Tree Program – District 2 example

```{r}
# Choose your focus council district here:
focus_district <- 2   # <-- change this to any district number if you like

# 1) Add an area column (in square meters) to council_districts
council_districts_area <- council_districts |>
  dplyr::mutate(
    shape_area = as.numeric(sf::st_area(geometry))
  ) |>
  dplyr::select(coun_dist, shape_area, geometry)

# 2) Join tree points to council districts (points inherit district + area info)
trees_with_district <- sf::st_join(
  tree_points,
  council_districts_area |> dplyr::select(coun_dist, shape_area),
  join = sf::st_within
)

# 3) Summarise by district: total trees, dead trees, density, fraction dead
district_summary <- trees_with_district |>
  sf::st_drop_geometry() |>
  dplyr::group_by(coun_dist) |>
  dplyr::summarise(
    n_trees    = dplyr::n(),
    n_dead     = sum(tpcondition == "Dead", na.rm = TRUE),
    shape_area = dplyr::first(shape_area),
    tree_density = n_trees / shape_area,   # trees per square meter
    frac_dead    = n_dead / n_trees
  ) |>
  dplyr::ungroup()
```

```{r}
focus_poly  <- council_districts_area |> dplyr::filter(coun_dist == focus_district)
focus_trees <- trees_with_district      |> dplyr::filter(coun_dist == focus_district)

bb <- sf::st_bbox(focus_poly)

ggplot2::ggplot() +
ggplot2::geom_sf(
data  = focus_poly,
fill  = "grey95",
color = "black",
linewidth = 0.5
) +
ggplot2::geom_sf(
data  = focus_trees,
ggplot2::aes(color = tpcondition),
size  = 0.7,
alpha = 0.7
) +
ggplot2::coord_sf(
xlim   = c(bb["xmin"], bb["xmax"]),
ylim   = c(bb["ymin"], bb["ymax"]),
expand = 0.02
) +
ggplot2::scale_color_brewer(
palette  = "Dark2",
na.value = "grey70",
name     = "Tree condition"
) +
ggplot2::labs(
title    = paste("Street Trees in NYC Council District", focus_district),
subtitle = "Zoomed-in view colored by tree condition",
caption  = "Data: NYC Forestry Tree Points & NYC City Council Districts"
) +
ggplot2::theme_minimal(base_size = 11) +
ggplot2::theme(
panel.background = ggplot2::element_rect(fill = "grey98", color = NA),
panel.grid.major = ggplot2::element_line(color = "grey90", linewidth = 0.2),
legend.position  = "right"
)
```

```{r}
# Compare your focus district with three others

comparison_dists <- c(focus_district, 1, 3, 4)

dead_comparison <- district_summary |>
dplyr::filter(coun_dist %in% comparison_dists) |>
dplyr::mutate(
district_label = paste("District", coun_dist),
district_label = forcats::fct_reorder(district_label, frac_dead)
)

ggplot2::ggplot(
dead_comparison,
ggplot2::aes(x = frac_dead, y = district_label, fill = district_label)
) +
ggplot2::geom_col() +
ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 0.1)) +
ggplot2::scale_fill_brewer(palette = "Set2", guide = "none") +
ggplot2::labs(
title    = "Fraction of Dead Trees by Council District",
subtitle = paste(
"District", focus_district,
"stands out as a priority for tree replacement"
),
x        = "Dead trees as % of all trees",
y        = "Council district"
) +
ggplot2::theme_minimal(base_size = 11) +
ggplot2::theme(
panel.grid.major = ggplot2::element_line(color = "purple", linewidth = 0.2)
)
```

# Extra Credit #02: Additional Parks Data

```{r extra02-risk, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(httr2)
library(readr)

# 1. Define the Forestry Risk download function
download_forestry_risk <- function(
  data_dir = "data/mp03_risk",
  base_url = "https://data.cityofnewyork.us/resource/259a-b6s7.csv",
  limit    = 50000
) {
  # Make sure directory exists
  dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)

  # Simple file naming pattern, no backslashes
  file_pattern <- "^forestry_risk_.*\\.csv$"

  # Look for cached files
  existing_files <- list.files(
    data_dir,
    pattern    = file_pattern,
    full.names = TRUE
  )

  if (length(existing_files) == 0) {
    offset <- 0L
    page   <- 1L

    repeat {
      message(sprintf("Requesting Forestry Risk page %d (offset = %d)...",
                      page, offset))

      # Polite httr2 request with $limit and $offset
      req <- httr2::request(base_url) |>
        httr2::req_url_query(
          "$limit"  = limit,
          "$offset" = offset
        )

      resp <- httr2::req_perform(req)
      txt  <- httr2::resp_body_string(resp)

      destfile <- file.path(
        data_dir,
        sprintf("forestry_risk_%03d.csv", page)
      )
      writeLines(txt, destfile)

      tmp <- readr::read_csv(destfile, show_col_types = FALSE)
      n   <- nrow(tmp)
      message(sprintf("  -> Retrieved %d risk assessment rows.", n))

      # Stop when last page has fewer than `limit` rows
      if (n < limit) break

      offset <- offset + limit
      page   <- page + 1L
    }

    # Refresh cached file list
    existing_files <- list.files(
      data_dir,
      pattern    = file_pattern,
      full.names = TRUE
    )
  } else {
    message("Using cached Forestry Risk files in ", data_dir)
  }

  # Read and combine all pages
  risk_list <- lapply(
    existing_files,
    readr::read_csv,
    show_col_types = FALSE
  )

  dplyr::bind_rows(risk_list)
}

# 2. Download (or load cached) risk data
forestry_risk <- download_forestry_risk()

# 3. Summarise risk counts (riskrating column) and make a colorful plot
risk_summary <- forestry_risk |>
  dplyr::filter(!is.na(riskrating)) |>
  dplyr::count(
    riskrating,
    name = "n_risk"
  ) |>
  dplyr::mutate(
    riskrating = factor(riskrating)
  )

ggplot(
  risk_summary,
  aes(x = riskrating, y = n_risk, fill = riskrating)
) +
  geom_col() +
  scale_fill_brewer(palette = "Reds", name = "Risk rating") +
  labs(
    title    = "NYC Forestry Risk Assessments by Risk Rating",
    subtitle = "Extra Credit: Additional NYC Parks risk dataset",
    x        = "Risk rating (higher = more severe failure risk)",
    y        = "Number of assessments"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    panel.grid.major = element_line(color = "grey90", linewidth = 0.2),
    axis.text.x      = element_text(angle = 20, hjust = 1)
  )
```